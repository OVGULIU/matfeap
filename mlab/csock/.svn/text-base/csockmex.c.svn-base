 #include "matsock.h"
 #include <stdlib.h>
/* --------------------------------------------------- */
/* Automatically generated by mwrap                    */
/* --------------------------------------------------- */

#include <mex.h>
#include <stdio.h>
#include <string.h>


#ifndef ulong
#  define ulong unsigned long
#endif
#ifndef uint
#  define uint  unsigned int
#endif
#ifndef uchar
#  define uchar unsigned char
#endif


/*
 * Support routines for copying data into and out of the MEX stubs
 */

void* mxWrapGetP(const mxArray* a, const char* fmt)
{
    void* p = 0;
    if (mxGetClassID(a) == mxDOUBLE_CLASS && 
        mxGetM(a)*mxGetN(a) == 1 && *mxGetPr(a) == 0)
        return p;
    if (mxIsChar(a)) {
        char pbuf[128];
        mxGetString(a, pbuf, sizeof(pbuf));
        sscanf(pbuf, fmt, &p);
    }
    if (p == 0)
        mexErrMsgTxt("Invalid pointer");
    return p;
}

mxArray* mxWrapCreateP(void* p, const char* fmt)
{
    if (p == 0) {
        mxArray* z = mxCreateDoubleMatrix(1,1, mxREAL);
        *mxGetPr(z) = 0;
        return z;
    } else {
        char pbuf[128];
        sprintf(pbuf, fmt, p);
        return mxCreateString(pbuf);
    }
}

mxArray* mxWrapStrncpy(const char* s)
{
    if (s) {
        return mxCreateString(s);
    } else {
        mxArray* z = mxCreateDoubleMatrix(1,1, mxREAL);
        *mxGetPr(z) = 0;
        return z;
    }
}

double mxWrapGetScalar(const mxArray* a)
{
    if (!a || mxGetClassID(a) != mxDOUBLE_CLASS || mxGetM(a)*mxGetN(a) != 1)
        mexErrMsgTxt("Invalid scalar argument");
    return *mxGetPr(a);
}

char* mxWrapGetString(const mxArray* a)
{
    char* s;
    int slen;
    if (!a || (!mxIsChar(a) && mxGetM(a)*mxGetN(a) > 0))
        mexErrMsgTxt("Invalid string argument");
    slen = mxGetM(a)*mxGetN(a) + 1;
    s = (char*) mxMalloc(slen);
    if (mxGetM(a)*mxGetN(a) == 0)
        *s = 0;
    else
        mxGetString(a, s, slen);
    return s;
}


#define mxWrapGetArrayDef(func, T) \
T* func(const mxArray* a) \
{ \
    T* array; \
    int arraylen; \
    int i; \
    T* p; \
    double* q; \
    if (!a || mxGetClassID(a) != mxDOUBLE_CLASS) \
        mexErrMsgTxt("Invalid array argument"); \
    arraylen = mxGetM(a)*mxGetN(a); \
    array = (T*) mxMalloc(mxGetM(a)*mxGetN(a) * sizeof(T)); \
    p = array; \
    q = mxGetPr(a); \
    for (i = 0; i < arraylen; ++i) \
        *p++ = (T) (*q++); \
    return array; \
}


#define mxWrapCopyDef(func, T) \
void func(mxArray* a, const T* q, int n) \
{ \
    int i; \
    double* p = mxGetPr(a); \
    for (i = 0; i < n; ++i) \
        *p++ = *q++; \
}


#define mxWrapReturnDef(func, T) \
mxArray* func(const T* q, int m, int n) \
{ \
    int i; \
    double* p; \
    if (!q) { \
        return mxCreateDoubleMatrix(0,0, mxREAL); \
    } else { \
        mxArray* a = mxCreateDoubleMatrix(m,n, mxREAL); \
        p = mxGetPr(a); \
        for (i = 0; i < m*n; ++i) \
            *p++ = *q++; \
        return a; \
    } \
}


#define mxWrapGetScalarZDef(func, T, ZT, setz) \
void func(T* z, const mxArray* a) \
{ \
    double* pr = mxGetPr(a); \
    double* pi = mxGetPi(a); \
    setz(z, (ZT) *pr, (pi ? (ZT) *pi : (ZT) 0)); \
}


#define mxWrapGetArrayZDef(func, T, ZT, setz) \
T* func(const mxArray* a) \
{ \
    T* array; \
    int arraylen; \
    int i; \
    T* p; \
    double* qr; \
    double* qi; \
    if (!a || mxGetClassID(a) != mxDOUBLE_CLASS) \
        mexErrMsgTxt("Invalid array argument"); \
    arraylen = mxGetM(a)*mxGetN(a); \
    array = (T*) mxMalloc(mxGetM(a)*mxGetN(a) * sizeof(T)); \
    p = array; \
    qr = mxGetPr(a); \
    qi = mxGetPi(a); \
    for (i = 0; i < arraylen; ++i) { \
        ZT val_qr = *qr++; \
        ZT val_qi = (qi ? (ZT) *qi++ : (ZT) 0); \
        setz(p, val_qr, val_qi); \
        ++p; \
    } \
    return array; \
}


#define mxWrapCopyZDef(func, T, real, imag) \
void func(mxArray* a, const T* q, int n) \
{ \
    int i; \
    double* pr = mxGetPr(a); \
    double* pi = mxGetPi(a); \
    for (i = 0; i < n; ++i) { \
        *pr++ = real(*q); \
        *pi++ = imag(*q); \
        ++q; \
    } \
}


#define mxWrapReturnZDef(func, T, real, imag) \
mxArray* func(const T* q, int m, int n) \
{ \
    int i; \
    double* pr; \
    double* pi; \
    if (!q) { \
        return mxCreateDoubleMatrix(0,0, mxCOMPLEX); \
    } else { \
        mxArray* a = mxCreateDoubleMatrix(m,n, mxCOMPLEX); \
        pr = mxGetPr(a); \
        pi = mxGetPi(a); \
        for (i = 0; i < m*n; ++i) { \
            *pr++ = real(*q); \
            *pi++ = imag(*q); \
            ++q; \
        } \
        return a; \
    } \
}

/* Array copier definitions */
mxWrapGetArrayDef(mxWrapGetArray_bool, bool)
mxWrapCopyDef    (mxWrapCopy_bool,     bool)
mxWrapReturnDef  (mxWrapReturn_bool,   bool)
mxWrapGetArrayDef(mxWrapGetArray_char, char)
mxWrapCopyDef    (mxWrapCopy_char,     char)
mxWrapReturnDef  (mxWrapReturn_char,   char)
mxWrapGetArrayDef(mxWrapGetArray_double, double)
mxWrapCopyDef    (mxWrapCopy_double,     double)
mxWrapReturnDef  (mxWrapReturn_double,   double)
mxWrapGetArrayDef(mxWrapGetArray_float, float)
mxWrapCopyDef    (mxWrapCopy_float,     float)
mxWrapReturnDef  (mxWrapReturn_float,   float)
mxWrapGetArrayDef(mxWrapGetArray_int, int)
mxWrapCopyDef    (mxWrapCopy_int,     int)
mxWrapReturnDef  (mxWrapReturn_int,   int)
mxWrapGetArrayDef(mxWrapGetArray_long, long)
mxWrapCopyDef    (mxWrapCopy_long,     long)
mxWrapReturnDef  (mxWrapReturn_long,   long)
mxWrapGetArrayDef(mxWrapGetArray_size_t, size_t)
mxWrapCopyDef    (mxWrapCopy_size_t,     size_t)
mxWrapReturnDef  (mxWrapReturn_size_t,   size_t)
mxWrapGetArrayDef(mxWrapGetArray_uchar, uchar)
mxWrapCopyDef    (mxWrapCopy_uchar,     uchar)
mxWrapReturnDef  (mxWrapReturn_uchar,   uchar)
mxWrapGetArrayDef(mxWrapGetArray_uint, uint)
mxWrapCopyDef    (mxWrapCopy_uint,     uint)
mxWrapReturnDef  (mxWrapReturn_uint,   uint)
mxWrapGetArrayDef(mxWrapGetArray_ulong, ulong)
mxWrapCopyDef    (mxWrapCopy_ulong,     ulong)
mxWrapReturnDef  (mxWrapReturn_ulong,   ulong)

/* ---- feapcsock.mw: 30 ----
 * int fd = matsock_new_tcp(cstring hostname, int port);
 */
const char* stubids1_ = "o int = matsock_new_tcp(i cstring, i int)";

void mexStub1(int nlhs, mxArray* plhs[],
              int nrhs, const mxArray* prhs[])
{
    char*       in0_;   /* hostname   */
    int         in1_;   /* port       */
    int         out0_;  /* fd         */

    in0_ = mxWrapGetString(prhs[0]);
    in1_ = (int) mxWrapGetScalar(prhs[1]);
    out0_ = matsock_new_tcp(in0_, in1_);
    plhs[0] = mxCreateDoubleMatrix(1, 1, mxREAL);
    *mxGetPr(plhs[0]) = out0_;
    mxFree(in0_);
}

/* ---- feapcsock.mw: 32 ----
 * int fd = matsock_new_unix(cstring hostname);
 */
const char* stubids2_ = "o int = matsock_new_unix(i cstring)";

void mexStub2(int nlhs, mxArray* plhs[],
              int nrhs, const mxArray* prhs[])
{
    char*       in0_;   /* hostname   */
    int         out0_;  /* fd         */

    in0_ = mxWrapGetString(prhs[0]);
    out0_ = matsock_new_unix(in0_);
    plhs[0] = mxCreateDoubleMatrix(1, 1, mxREAL);
    *mxGetPr(plhs[0]) = out0_;
    mxFree(in0_);
}

/* ---- feapcsock.mw: 39 ----
 * matsock_close(int fd);
 */
const char* stubids3_ = "matsock_close(i int)";

void mexStub3(int nlhs, mxArray* plhs[],
              int nrhs, const mxArray* prhs[])
{
    int         in0_;   /* fd         */

    in0_ = (int) mxWrapGetScalar(prhs[0]);
    matsock_close(in0_);
}

/* ---- feapcsock.mw: 43 ----
 * matsock_recv(int fd, output cstring[1024] s, int 1024);
 */
const char* stubids4_ = "matsock_recv(i int, o cstring[x], i int)";

void mexStub4(int nlhs, mxArray* plhs[],
              int nrhs, const mxArray* prhs[])
{
    int         in0_;   /* fd         */
    int         in1_;   /* 1024       */
    char*       out0_;  /* s          */
    int         dim2_;  /* 1024       */

    dim2_ = (int) mxWrapGetScalar(prhs[2]);

    in0_ = (int) mxWrapGetScalar(prhs[0]);
    in1_ = (int) mxWrapGetScalar(prhs[1]);
    out0_ = (char*) mxMalloc(dim2_*sizeof(char));
    matsock_recv(in0_, out0_, in1_);
    plhs[0] = mxCreateString(out0_);
    mxFree(out0_);
}

/* ---- feapcsock.mw: 47 ----
 * matsock_send(int fd, cstring s);
 */
const char* stubids5_ = "matsock_send(i int, i cstring)";

void mexStub5(int nlhs, mxArray* plhs[],
              int nrhs, const mxArray* prhs[])
{
    int         in0_;   /* fd         */
    char*       in1_;   /* s          */

    in0_ = (int) mxWrapGetScalar(prhs[0]);
    in1_ = mxWrapGetString(prhs[1]);
    matsock_send(in0_, in1_);
    mxFree(in1_);
}

/* ---- feapcsock.mw: 51 ----
 * matsock_recvdarray(int fd, output double[len] val, int len);
 */
const char* stubids6_ = "matsock_recvdarray(i int, o double[x], i int)";

void mexStub6(int nlhs, mxArray* plhs[],
              int nrhs, const mxArray* prhs[])
{
    int         in0_;   /* fd         */
    int         in1_;   /* len        */
    double*     out0_;  /* val        */
    int         dim2_;  /* len        */

    dim2_ = (int) mxWrapGetScalar(prhs[2]);

    in0_ = (int) mxWrapGetScalar(prhs[0]);
    in1_ = (int) mxWrapGetScalar(prhs[1]);
    out0_ = (double*) mxMalloc(dim2_*sizeof(double));
    matsock_recvdarray(in0_, out0_, in1_);
    plhs[0] = mxCreateDoubleMatrix(dim2_, 1, mxREAL);
    mxWrapCopy_double(plhs[0], out0_, dim2_);
    mxFree(out0_);
}

/* ---- feapcsock.mw: 55 ----
 * matsock_recviarray(int fd, output int[len] val, int len);
 */
const char* stubids7_ = "matsock_recviarray(i int, o int[x], i int)";

void mexStub7(int nlhs, mxArray* plhs[],
              int nrhs, const mxArray* prhs[])
{
    int         in0_;   /* fd         */
    int         in1_;   /* len        */
    int*        out0_;  /* val        */
    int         dim2_;  /* len        */

    dim2_ = (int) mxWrapGetScalar(prhs[2]);

    in0_ = (int) mxWrapGetScalar(prhs[0]);
    in1_ = (int) mxWrapGetScalar(prhs[1]);
    out0_ = (int*) mxMalloc(dim2_*sizeof(int));
    matsock_recviarray(in0_, out0_, in1_);
    plhs[0] = mxCreateDoubleMatrix(dim2_, 1, mxREAL);
    mxWrapCopy_int(plhs[0], out0_, dim2_);
    mxFree(out0_);
}

/* ---- feapcsock.mw: 60 ----
 * matsock_senddarray(int fd, double[] x, int len);
 */
const char* stubids8_ = "matsock_senddarray(i int, i double[], i int)";

void mexStub8(int nlhs, mxArray* plhs[],
              int nrhs, const mxArray* prhs[])
{
    int         in0_;   /* fd         */
    double*     in1_;   /* x          */
    int         in2_;   /* len        */

    in0_ = (int) mxWrapGetScalar(prhs[0]);
    if (mxGetM(prhs[1])*mxGetN(prhs[1]) != 0)
        in1_ = mxGetPr(prhs[1]);
    else
        in1_ = NULL;
    in2_ = (int) mxWrapGetScalar(prhs[2]);
    matsock_senddarray(in0_, in1_, in2_);
}

/* ---- feapcsock.mw: 65 ----
 * matsock_sendiarray(int fd, int[] x, int len);
 */
const char* stubids9_ = "matsock_sendiarray(i int, i int[], i int)";

void mexStub9(int nlhs, mxArray* plhs[],
              int nrhs, const mxArray* prhs[])
{
    int         in0_;   /* fd         */
    int*        in1_;   /* x          */
    int         in2_;   /* len        */

    in0_ = (int) mxWrapGetScalar(prhs[0]);
    if (mxGetM(prhs[1])*mxGetN(prhs[1]) != 0)
        in1_ = mxWrapGetArray_int(prhs[1]);
    else
        in1_ = NULL;
    in2_ = (int) mxWrapGetScalar(prhs[2]);
    matsock_sendiarray(in0_, in1_, in2_);
    mxFree(in1_);
}

/* ---- feapcsock.mw: 70 ----
 * cstring usrenv = getenv(cstring usrvar);
 */
const char* stubids10_ = "o cstring = getenv(i cstring)";

void mexStub10(int nlhs, mxArray* plhs[],
              int nrhs, const mxArray* prhs[])
{
    char*       in0_;   /* usrvar     */

    in0_ = mxWrapGetString(prhs[0]);
    plhs[0] = mxWrapStrncpy(getenv(in0_));
    mxFree(in0_);
}

/* ----
 */
void mexFunction(int nlhs, mxArray* plhs[],
                 int nrhs, const mxArray* prhs[])
{
    char id[512];
    if (nrhs == 0) {
        mexPrintf("Mex function installed\n");
        return;
    }

    if (mxGetString(prhs[0], id, sizeof(id)) != 0)
        mexErrMsgTxt("Identifier should be a string");
    else if (strcmp(id, stubids1_) == 0)
        mexStub1(nlhs,plhs, nrhs-1,prhs+1);
    else if (strcmp(id, stubids2_) == 0)
        mexStub2(nlhs,plhs, nrhs-1,prhs+1);
    else if (strcmp(id, stubids3_) == 0)
        mexStub3(nlhs,plhs, nrhs-1,prhs+1);
    else if (strcmp(id, stubids4_) == 0)
        mexStub4(nlhs,plhs, nrhs-1,prhs+1);
    else if (strcmp(id, stubids5_) == 0)
        mexStub5(nlhs,plhs, nrhs-1,prhs+1);
    else if (strcmp(id, stubids6_) == 0)
        mexStub6(nlhs,plhs, nrhs-1,prhs+1);
    else if (strcmp(id, stubids7_) == 0)
        mexStub7(nlhs,plhs, nrhs-1,prhs+1);
    else if (strcmp(id, stubids8_) == 0)
        mexStub8(nlhs,plhs, nrhs-1,prhs+1);
    else if (strcmp(id, stubids9_) == 0)
        mexStub9(nlhs,plhs, nrhs-1,prhs+1);
    else if (strcmp(id, stubids10_) == 0)
        mexStub10(nlhs,plhs, nrhs-1,prhs+1);
    else
        mexErrMsgTxt("Unknown identifier");
}

