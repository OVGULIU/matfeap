\section{Interface to the Java socket helper}

The Java socket helper class is a thin layer that lets us use
Java stream descriptors and binary I/O routines.  We use it to
establish socket connections, send an recieve lines of data,
etc.

The socket routines are
\begin{itemize}
\item {\tt sock\_new(hostname,port)} - start a socket connection
\item {\tt sock\_new(command)} - start a pipe connection
\item {\tt sock\_close(js)} - close a socket
\item {\tt sock\_recv(js)} - read a line of data
\item {\tt sock\_send(js)} - send a line of data
\item {\tt sock\_readdarray(js, len)} - read {\tt len} 64-bit doubles
into an array
\item {\tt sock\_readiarray(js, len)} - read {\tt len} 32-bit integers
into an array
\item {\tt sock\_senddarray(js, array)} - send an array of 64-bit doubles
\item {\tt sock\_sendiarray(js, array)} - send an array of 32-bit integers
\end{itemize}

\section{Interface to the C socket helper}

The C socket library provides a MEX interface to both TCP and
UNIX domain sockets.  This library can be used with MATLAB as an
alternative to the Java socket library; or it can be used with
recent versions of Octave. 

The C socket routines are identical to the Java socket routines,
save for {\tt sock\_new}:
\begin{itemize}
\item {\tt sock\_new(hostname,port)} - start a TCP socket connection
\item {\tt sock\_new(sockname)} - start a UNIX socket connection
\end{itemize}

In addition, we provide a routine that queries the environment to
figure out an appropriate name for a UNIX-domain socket to the server:
\begin{itemize}
\item {\tt sock\_default\_unix} - return the default UNIX socket name
\end{itemize}
\section {Communication setup}

These routines are used to specify which of the three communication modes
available to MATFEAP should be used.

\subsection{Setting up pipe communication}

The {\tt feaps\_pipe} function tells MATFEAP to manage communication
over a bidirectional pipe managed by Java.  This method is not
available in the C interface -- there the prefered connection method is
a UNIX-domain socket.

The default location for the FEAP executable used by in pipe mode is
{\tt {\it MATFEAP}/srv/feapp}.  The location of the {\tt feaps\_pipe.m}
file should be {\tt {\it MATFEAP}/srv/feaps\_pipe.m}.  Since the latter
file is obviously on the MATLAB path, we can get the fully qualified
name from MATLAB and extract the location of the MATFEAP home directory
from it.

\begin{verbatim}
function feaps_pipe(cmd)

global matfeap_globals
matfeap_globals.sockname = [];
matfeap_globals.server   = [];
matfeap_globals.port     = [];

if nargin < 1
  s = which('feaps_pipe.m');
  i = strfind(s, 'feaps_pipe.m')-length('mlab/');
  matfeap_globals.command = [s(1:i-1), 'srv/feapp'];
  fprintf('Using FEAP in pipe mode: %s\n', matfeap_globals.command);
elseif isempty(cmd)
  matfeap_globals.command = [];
  fprintf('Turning off FEAP pipe mode\n');
else
  matfeap_globals.command = cmd;
end

\end{verbatim}
\subsection{Setting up TCP socket communication}

The {\tt feaps\_tcp} function tells MATFEAP to manage communication
over a TCP socket (which may be managed by Java or C).  The default
location for the server is the local host on port 3490.

\begin{verbatim}
function feaps_tcp(server, port)

global matfeap_globals
matfeap_globals.command  = [];
matfeap_globals.sockname = [];
matfeap_globals.server   = [];
matfeap_globals.port     = [];

if nargin < 1
  matfeap_globals.server = '127.0.0.1';
  matfeap_globals.port   = 3490;
elseif nargin == 1
  if isempty(server)
    fprintf('Turning off FEAP TCP mode\n');
    return;
  elseif isnumeric(server)
    matfeap_globals.server = '127.0.0.1';
    matfeap_globals.port   = server;
  else
    matfeap_globals.server = server;
    matfeap_globals.port   = 3490;
  end
else
  matfeap_globals.server = server;
  matfeap_globals.port   = port;
end

fprintf('Using FEAP in TCP mode: %s:%d\n', ...
        matfeap_globals.server, matfeap_globals.port);

\end{verbatim}
\subsection{Setting up UNIX socket communication}

The {\tt feaps\_unix} function tells MATFEAP to manage communication
over a UNIX-domain socket.  This option is only available with the C
interface.  UNIX-domain sockets are identified by filesystem locations,
typically placed under {\tt /tmp}.  For MATFEAP, we use the default
name {\tt /tmp/feaps-{\it USER}}, where {\it USER} is the user name in
the current environment.  Because MATLAB doesn't have direct access to
the environment, we fetch the default socket name through the wrapper
function {\tt sock\_default\_unix}.

\begin{verbatim}
function feaps_unix(sockname)

global matfeap_globals
matfeap_globals.command  = [];
matfeap_globals.sockname = [];
matfeap_globals.server   = [];
matfeap_globals.port     = [];

if nargin < 1
  matfeap_globals.sockname = sock_default_unix;
elseif nargin == 1
  if isempty(sockname)
    fprintf('Turning off FEAP UNIX mode\n');
    return;
  else
    matfeap_globals.sockname = sockname;
  end
end

fprintf('Using FEAP on UNIX socket: %s\n', matfeap_globals.sockname);

\end{verbatim}
\section{Starting FEAP}

The {\tt feapstart} command is used to launch a new FEAP process:
\begin{verbatim}
function p = feapstart(fname, params)
\end{verbatim}

The file name argument is required.  The optional {\tt params}
argument plays double duty: a set of special parameters are used
to control things about the MATFEAP interface, and the remaining
parameters are used to initialize the FEAP variable list before
opening the designated input deck.
\subsection{Merging global parameters}

The {\tt matfeap\_globals} variable is used to provide default
values for the fields in the {\tt params} structure, if explicit
values are not otherwise provided.

\begin{verbatim}
global matfeap_globals;

if isstruct(matfeap_globals)
  if isempty(params)
    params = matfeap_globals;
  else
    pnames = fieldnames(matfeap_globals);
    for k = 1:length(pnames)
      if ~isfield(params, pnames{k})
        pvalue = getfield(matfeap_globals, pnames{k});
        params = setfield(params, pnames{k}, pvalue);
      end
    end
  end
end

\end{verbatim}
\subsection{Special parameters}

The special parameters are
\begin{itemize}
\item {\tt verbose}: if true, output all the stuff that FEAP sends
\item {\tt server} and {\tt port}: the server host name
(string) and port number (integer)
\item {\tt command}: if defined, this string says how to
execute the extended FEAP directly from the command line.
Used as an alternative to opening a socket connection.
\item {\tt dir}: the starting directory to change to after
connecting to the FEAP server.  By default we use the
client's present working directory.
\end{itemize}

At the same time we process these parameters, we remove them
from the {\tt param} structure.  That way, everything remaining
in the {\tt param} structure after this step can be interpreted
as a FEAP input parameter.

\begin{verbatim}
verb    = 0;           % Are we in verbose mode?
server  = '127.0.0.1'; % Server where FEAP is located
port    = 3490;        % Port where FEAP is located
dir     = pwd;         % Base directory to use for rel paths
command = [];          % Command string to use with pipe interface
sockname = [];         % UNIX domain socket name

if ~isempty(params)
  if isfield(params, 'verbose')
    verb = params.verbose;
    params = rmfield(params, 'verbose');
  end
  if isfield(params, 'server')
    server = params.server;
    params = rmfield(params, 'server');
  end
  if isfield(params, 'port')
    port = params.port;
    params = rmfield(params, 'port');
  end
  if isfield(params, 'command')
    command = params.command;
    params = rmfield(params, 'command');
  end
  if isfield(params, 'sockname')
    sockname = params.sockname;
    params = rmfield(params, 'sockname');
  end
  if isfield(params, 'dir')
    dir = params.dir;
    params = rmfield(params, 'dir');
  end
end


\end{verbatim}
\subsection{Input deck directory}

I assume that the file name does not contain any slashes or
backslashes; if those occur in the input deck name, then we'll
split the name argument into {\tt pathname} and {\tt fname}.

\begin{verbatim}
lastslash = max([strfind(fname, '/'), strfind(fname, '\')]);
if ~isempty(lastslash)
  pathname = fname(1:lastslash-1);
  fname = fname(lastslash+1:end);
else
  pathname = [];
end


\end{verbatim}
\subsection{Opening FEAP}

If {\tt sockname} is nonempty, then the user has specified
a UNIX domain socket to connect to the FEAP server.  Otherwise
if {\tt command} is nonempty, then the user has specified the
name of a command to start the (extended) FEAP.  This FEAP
executable has the same interface as the socket-based version,
but it communicates using the ordinary standard I/O streams,
which we will connect to a pipe.  Otherwise, we'll try to
communicate with the server via TCP.  We give the same generic error
message in the event of any error -- ``is the server there?''

Once a connection to the FEAP process has been established,
we save the relevant Java helper (or C handle) and the verbosity flag 
together in a handle structure.  This structure is the first argument 
to all the high-level MATFEAP interface functions.

\begin{verbatim}
try
  if ~isempty(sockname)
    fd = sock_new(sockname);
  elseif ~isempty(command)
    fd = sock_new(command);
  else
    fd = sock_new(server, port);
  end
catch
  fprintf('Could not open connection -- is the FEAP server running?\n');
  error(lasterr);
end

p = [];
p.fd = fd;
p.verb = verb;

\end{verbatim}
\subsection{Passing parameters}

The {\tt param} command in the {\tt feapsrv} interface allows the
user to send parameters to FEAP.  Parameter assignments have the
form ``param var val''.  Invalid assignments are (perhaps suboptimally)
simply ignored.

\begin{verbatim}
feapsrvp(p);
if ~isempty(params)
  pnames = fieldnames(params);
  for k = 1:length(pnames)
    pvar = pnames{k};
    pval = getfield(params, pnames{k});
    if ~isnumeric(pval)
      fprintf('Ignoring non-numeric parameter %s\n', pvar);
    else
      sock_send(fd, sprintf('param %s %g', pvar, pval));
      feapsrvp(p);
    end
  end
end

\end{verbatim}
\subsection{Setting the current directory}

If a home directory was specified via a {\tt dir} special
argument, we first change to that directory (by default, we
change to the client's present working directory).  If a path was
specified as part of the input deck name, we then change to that
directory.  If both {\tt dir} and {\tt pathname} are non-empty
and the {\tt pathname} specifies a relative path, we will end up
in the path relative to the specified base directory.

The {\tt feapsrv} command to change directories will return a
diagnostic message if for any reason the directory change doesn't
go through.  We ignore said message.

\begin{verbatim}
if ~isempty(dir)
  sock_send(fd, ['cd ', dir]);
  feapsrvp(p);
end
if ~isempty(pathname)
  sock_send(fd, ['cd ', pathname]);
  feapsrvp(p);
end

\end{verbatim}
\subsection{Sending the file names}

Once we've set up the parameter string and changed to the proper
directory, we're ready to actually start processing an input
deck.  The {\tt start} command gets us out of the {\tt feapsrv}
interface and into ordinary FEAP interactions.  We now need to
send to FEAP:
\begin{enumerate}
\item
The name of the input deck.
\item
Blank lines to say ``we accept the default names for the
auxiliary files.''  The number of auxiliary files has changed
over time, which is why we don't use a counter -- we just send
a blank line at every synchronization message until we see a
string that indicates that we've entered all the desired file
names.
\item
A string ``y'' for when we're asked if the file names are
correct.
\end{enumerate}

If an error occurs during entering the file name, we send the
``quit'' string and get out of dodge.  In response to a request
to quit, FEAP will go through the ordinary shutdown procedure,
so we'll wait for the last synchronization message before closing
the connection.

\begin{verbatim}
sock_send(fd, 'start');
feapsync(p);
sock_send(fd, fname);

doneflag = 0;
while 1
  s = sock_recv(fd);
  if strfind(s, '*ERROR*')
    p.verb = 1;
    feapsync(p);
    sock_send(fd, 'quit');
    feapsync(p);
    sock_close(fd);
    p = [];
    return;
  elseif strfind(s, 'Files are set')
    feapdispv(p, s);
    feapsync(p);
    sock_send(fd, 'y')
    feapsync(p);
    return;
  elseif strfind(s, 'MATFEAP SYNC')
    sock_send(fd, '');
  else
    feapdispv(p, s);
  end
end
\end{verbatim}
\section {User commands}

These are the main routines in the interface used directly by MATFEAP
users.

\subsection{Invoking FEAP macro commands}

The {\tt feapcmd} routine is used to invoke FEAP macro routines.
It's up to the user to ensure that after the end of the last command
in the list, FEAP is back at a prompt involving a {\tt tinput}
command (e.g. the macro prompt or a plot prompt).

The {\tt feapcmd} routine should not be used to quit FEAP; use
{\tt feapquit} for that.

\begin{verbatim}
function feapcmd(p, varargin)

for k = 1:length(varargin)
  sock_send(p.fd, varargin{k});
  feapsync(p);
end
\end{verbatim}
\subsection{Exiting FEAP}

The {\tt feapquit} command invokes the quit command, says ``n''
when asked whether we would like to continue, waits for the
sign-off synchronization message, and shuts down the connection.
This is the graceful way to exit from FEAP.  In contrast, the
{\tt feapkill} command should be treated as a last-ditch effort
to kill a misbehaving FEAP process.

\begin{verbatim}
function feapquit(p)

sock_send(p.fd, 'quit');
feapsync(p);
sock_send(p.fd, 'n');
feapsync(p,1);
sock_close(p.fd);
\end{verbatim}
\begin{verbatim}
function feapkill(p)

sock_close(p.fd);
\end{verbatim}
\subsection{Putting MATFEAP into verbose mode}

In verbose mode, you can see all the interactions between MATFEAP
and FEAP.  It's possible to switch to verbose mode by setting the
{\tt verbose} field in the parameter structure for {\tt feapstart},
or by setting the {\tt matfeap\_globals} structure directly; but
I find myself wanting to see verbose output fairly regularly, so
it seemed worthwhile to have a special method for it.

\begin{verbatim}
function feaps_verb

global matfeap_globals;
matfeap_globals.verbose = 1;
\end{verbatim}
\section {Basic getter / setter interfaces}

These are the MATLAB interface routines that get and set FEAP
matrices, arrays, and scalars.

\subsection{Getting scalar values}

To get a scalar variable, we enter the {\tt feapsrv} interface
and issue a {\tt get {it varname}} request.  Either it succeeds,
in which case the variable is printed; or it fails, in which case
nothing is printed.  We silently return an empty array to
indicate the latter case.  After retrieving the variable, we
issue a {\tt start} command to exit the {\tt feapsrv} interface
and get back to the FEAP macro prompt.

\begin{verbatim}
function val = feapget(p, var)

if nargin < 2,   error('Missing required argument');      end
if ~ischar(var), error('Variable name must be a string'); end

sock_send(p.fd, 'serv');
feapsrvp(p);
cmd = sprintf('get %s', lower(var));
feapdispv(p, cmd);
sock_send(p.fd, cmd);

val = [];
resp = sock_recv(p.fd);
if ~strcmp(resp, 'FEAPSRV> ')
  val = sscanf(resp, '%g');
  feapdispv(p, resp);
  feapsrvp(p);
end
sock_send(p.fd, 'start');
feapsync(p);
\end{verbatim}
\subsection{Getting arrays}

This routine implements the client side of the array fetch
protocol described in the {\tt feapsrv} documentation.  We enter
the {\tt feapsrv} command interface, issue a request for a
matrix, read the server's description of the matrix size and
type, and then either start an appropriate binary data transfer
or bail if something looks malformed.  After all this, we return
to the FEAP macro interface.

\begin{verbatim}
function val = feapgetm(p, var)

if nargin < 2,   error('Missing required argument');      end
if ~ischar(var), error('Variable name must be a string'); end

sock_send(p.fd, 'serv');
feapsrvp(p);
cmd = sprintf('getm %s', upper(var));
feapdispv(p, cmd);
sock_send(p.fd, cmd);

resp = sock_recv(p.fd);
[s, resp] = strtok(resp);
val = [];
if strcmp(s, 'Send')
  [datatype, resp] = strtok(resp);  % Data type (int | double)
  [len,      resp] = strtok(resp);  % Number of entries
  len = str2num(len);
  if strcmp(datatype, 'int')
    feapdispv(p, sprintf('Receive %d ints...', len));
    sock_send(p.fd, 'binary')
    val = sock_recviarray(p.fd, len);
  elseif strcmp(datatype, 'double')
    feapdispv(p, sprintf('Receive %d doubles...', len));
    sock_send(p.fd, 'binary')
    val = sock_recvdarray(p.fd, len);
  else
    feapdispv(p, 'Did not recognize response, bailing');
    sock_send(p.fd, 'cancel')
  end
end

feapsrvp(p);
sock_send(p.fd, 'start')
feapsync(p);
\end{verbatim}
\subsection{Setting arrays}

This routine implements the client side of the array set
protocol described in the {\tt feapsrv} documentation.  It is
exactly analogous to {\tt feapgetm}, except that now we have to
make sure that we're sending the right amount of data.  We should
almost certainly advertize more clearly when we've exited because
the specified array was the wrong size.

\begin{verbatim}
function feapsetm(p, var, val)

sock_send(p.fd, 'serv');
feapsrvp(p);
cmd = sprintf('setm %s', upper(var));
feapdispv(p, cmd);
sock_send(p.fd, cmd);

resp = sock_recv(p.fd);
[s, resp] = strtok(resp);
if strcmp(s, 'Recv')
  [datatype, resp] = strtok(resp);
  [len, resp] = strtok(resp);
  len = str2num(len);
  if len ~= prod(size(val))
    feapdispv(p, sprintf('Expected size %d; bailing', len));
    sock_send(p.fd, 'cancel');
  elseif strcmp(datatype, 'int')
    feapdispv(p, sprintf('Sending %d ints...', len));
    sock_send(p.fd, 'binary')
    sock_sendiarray(p.fd, val);
  elseif strcmp(datatype, 'double')
    feapdispv(p, sprintf('Sending %d doubles...', len));
    sock_send(p.fd, 'binary')
    sock_senddarray(p.fd, val);
  else
    feapdispv(p, 'Did not recognize response, bailing');
    sock_send(p.fd, 'cancel')
  end
end

feapsrvp(p);
sock_send(p.fd, 'start')
feapsync(p);
\end{verbatim}
\subsection{Getting sparse matrices}

This routine implements the client side of the sparse matrix fetch
protocol described in the {\tt feapsrv} documentation.  We start
the {\tt feapsrv} command interface, request the array, read the
number of nonzero entries, and either fetch a block of binary
data and convert it to a sparse matrix, or bail if we saw
something unexpected.

\begin{verbatim}
function val = feapgetsparse(p, var)

if nargin < 2,   error('Wrong number of arguments'); end
if ~ischar(var), error('Variable name must be a string'); end
if length(var) < 1, error('Variable name must be at least one char'); end

sock_send(p.fd, 'serv');
feapsrvp(p);
cmd = sprintf('sparse binary %s', lower(var));
feapdispv(p, cmd);
sock_send(p.fd, cmd);

resp = sock_recv(p.fd);
[s, resp] = strtok(resp);
val = [];
if strcmp(s, 'nnz')
  [len, resp] = strtok(resp);
  len = str2num(len);
  feapdispv(p, sprintf('Receive %d matrix entries...', len));
  val = sock_recvdarray(p.fd, 3*len);
  val = reshape(val, 3, len);
  val = sparse(val(1,:), val(2,:), val(3,:));
end

feapsrvp(p);
sock_send(p.fd, 'start')
feapsync(p);
\end{verbatim}
\section {Getting stiffness, mass, and damping}

These are the high-level interface routines that fetch or write
the main FEAP sparse matrices.

\subsection{Tangent matrix}

The {\tt feaptang} and {\tt feaputan} routines call FEAP macros
to form the tangent stiffness matrix (symmetric or unsymmetric)
without factoring it, and then retrieve the matrix into MATLAB.

\begin{verbatim}
function K = feaptang(p)

feapcmd(p, 'tang,,-1');
K = feapgetsparse(p, 'tang');
\end{verbatim}
\begin{verbatim}
function K = feaputan(p)

feapcmd(p, 'utan,,-1');
K = feapgetsparse(p, 'utan');
\end{verbatim}
\subsection{Mass matrix}

The {\tt feapmass} and {\tt feapumass} routines call FEAP macros
to form the mass (symmetric or unsymmetric), and then retrieve
the matrix into MATLAB.  This high-level interface only allows
you to get the consistent mass, and not the lumped mass.

\begin{verbatim}
function M = feapmass(p)

feapcmd(p, 'mass');
M = feapgetsparse(p, 'mass');
\end{verbatim}
\begin{verbatim}
function M = feapumass(p)

feapcmd(p, 'mass,unsy');
M = feapgetsparse(p, 'umas');
\end{verbatim}
\subsection{Damping matrix}

The {\tt feapdamp} and {\tt feapudamp} routines call FEAP macros
to form the damping (symmetric or unsymmetric), and then retrieve
the matrix into MATLAB.

\begin{verbatim}
function D = feapdamp(p)

feapcmd(p, 'damp');
D = feapgetsparse(p, 'damp');
\end{verbatim}
\begin{verbatim}
function D = feapudamp(p)

feapcmd(p, 'damp,unsy');
D = feapgetsparse(p, 'damp');
\end{verbatim}
\section {Getting and setting {\tt X}, {\tt U}, and {\tt F} vectors}

These are the high-level interface routines that fetch or write
the node position, displacement, and residual vectors.

\subsection{Getting the displacement}

The {\tt feapgetu} command retrieves the full displacement array
{\tt U} and returns some subset of it.  By default, we extract the
active degrees of freedom in the reduced order, using
{\tt map2full} to retrieve the appropriate reindexing vector.

\begin{verbatim}
function u = feapgetu(p, id)

if nargin < 2, id = map2full(p); end
u = feapgetm(p, 'u');
u = u(id);
\end{verbatim}
\subsection{Setting the displacement}

The {\tt feapsetu} command sets some subset of the displacement
array {\tt U} (by default, we set the active degrees of
freedom).  If we don't provide a vector to write out, then the
assumption is that we want to clear the displacement vector to
zero, save for any essential boundary conditions (which FEAP
keeps in the second part of the {\tt F} array).

\begin{verbatim}
function feapsetu(p,u, id)

if nargin < 3, [id, bc_id] = map2full(p); end
u1 = feapgetm(p,'u');

if nargin < 2
  nneq        = feapget(p,'nneq');
  f           = feapgetm(p,'f');
  u1(bc_id)   = f(bc_id + nneq);
end

u1(id) = u;
feapsetm(p, 'u', u1);
\end{verbatim}
\subsection{Getting the nodal positions}

The {\tt feapgetx} command gets the nodal position matrix {\tt X}
and, optionally, a parallel matrix of displacements.  These
displacements can be extracted from a displacement vector passed
in as an argument, or they can be retrieved from the FEAP {\tt U}
array.

\begin{verbatim}
function [xx, uu] = feapgetx(p,u)

% Get mesh parameters
nnp  = feapget(p,'numnp'); % Number of nodal points
nneq = feapget(p,'nneq');  % Number of unreduced dof
neq  = feapget(p,'neq');   % Number of dof
ndm  = feapget(p,'ndm');   % Number of spatial dimensions
ndf  = feapget(p,'ndf');   % Maximum dof per node

% Get node coordinates from FEAP
xx = feapgetm(p,'x');
xx = reshape(xx, ndm, length(xx)/ndm);

if nargout > 1

  % Extract u if not provided
  if nargin < 1, u = feapgetu(p); end

  % Find out how to map reduced to full dof set
  id   = feapgetm(p,'id');
  id   = reshape(id(1:nneq), ndf, nnp);
  idnz = find(id > 0);

  % Get full dof set
  uu       = zeros(ndf, nnp);
  uu(idnz) = u(id(idnz));

end
\end{verbatim}
\subsection{Getting the residual}

The {\tt feapresid} function forms the residual and fetches it
from FEAP memory.  If the user provides a reduced displacement
vector {\tt u} as an argument, then that vector will be written
to FEAP's array of nodal unknowns before evaluating the residual.

The one thing that's a little tricky about {\tt feapresid} has to do
with an optimization in FEAP.  Usually, calls to the FEAP macro to
form the residual don't do anything unless there has been a solve
step since the previous request for a residual form.  But when we
modify the displacements and boundary conditions behind FEAP's back,
we typically invalidate the current residual, whatever it may be.
So before requesting that FEAP form a new residual, we use the 
{\tt feapsrv} interface to clear the flag that says that the residual has
already been formed.

\begin{verbatim}
function R = feapresid(p, u, id)

if nargin == 2
  feapsetu(p,u);
elseif nargin == 3
  feapsetu(p,u, id);
end

sock_send(p.fd,'serv');
feapsrvp(p);
feapdispv(p, 'clear_isformed');
sock_send(p.fd, 'clear_isformed');
feapsrvp(p);
sock_send(p.fd, 'start');
feapsync(p);

feapcmd(p,'form');
R = feapgetm(p,'dr');
R = R(1:feapget(p,'neq'));
\end{verbatim}
\section {Utility commands}

These are low-level routines that should generally be invisible
to the user.

\subsection{Waiting for synchronization}

The {\tt feapsync} command is used to wait for a synchronization
message sent by the server.  For the moment, we don't use the
synchronization labels.

\begin{verbatim}
function feapsync(p, barriernum)

if nargin == 1, barriernum = 0; end

while 1
  s = sock_recv(p.fd);
  if strfind(s, 'MATFEAP SYNC')
    if barriernum == 0
      break;
    elseif strcmp(s, sprintf('MATFEAP SYNC %d', barriernum))
      break
    else
      feapdispv(p, 'Unexpected barrier');
      feapdispv(p, s);
    end
  else
    feapdispv(p, s);
  end
end
\end{verbatim}
\subsection{Waiting for {\tt FEAPSRV}}

The {\tt feapsrvp} command is used to wait for the server to send
a {\tt FEAPSRV} prompt when using the {\tt feapsrv} command
interface.

\begin{verbatim}
function s = feapsrvp(p, prompt)

while 1
  s = sock_recv(p.fd);
  feapdispv(p, s);
  if strfind(s, 'FEAPSRV>'), break; end
end
\end{verbatim}
\subsection{Verbose output}

The {\tt feapdispv} routine is used to write messages to the
standard output conditioned on the FEAP server being in verbose
mode.  This is useful if you want to look at the output of FEAP
for debugging purposes.

\begin{verbatim}
function feapdispv(p, msg)

if p.verb
  if length(msg) == 0, msg = ' '; end 
  disp(msg);
end
\end{verbatim}
\subsection{Index mapping}

The {\tt ID} array in FEAP is used to keep track of which nodal
variables are active and which are determined by some boundary
condition.  We return the relevant portion of the {\tt ID} array
along with:
\begin{enumerate}
\item 
The indices of all active degrees of freedom ({\tt full\_id}).
\item
The indices of all variables subject to BCs ({\tt bc\_id}).
\item
An array to map the indices of the active degrees of freedom
in the full vector to indices in a reduced vector ({\tt reduced\_id}).
\end{enumerate}

\begin{verbatim}
function [full_id, bc_id, reduced_id, id] = map2full(p)

% Get mesh parameters
nneq  = feapget(p, 'nneq');  % Number of unreduced dof
numnp = feapget(p, 'numnp'); % Number of dof
ndf   = feapget(p, 'ndf');   % Maximum dof per node

% Get the index map
id = feapgetm(p, 'id');
id = reshape(id(1:nneq), ndf, numnp);

% Find the index set for free vars in full and reduced vectors
full_id    = find(id >  0);
bc_id      = find(id <= 0);
reduced_id = id(full_id);
\end{verbatim}
