\section{Adding synchronization on input}

We have our own version of the input routine {\tt tinput},
which mediates most of the console input in FEAP.  Our version
calls {\tt feapsync} to allow the client to sync up with the
server, then calls {\tt tinput2}, which is generated from the
ordinary {\tt tinput} routine in FEAP.

\begin{verbatim}
      logical function tinput(tx,mt,d,nn)

      include  'iofile.h'

      logical   tinput2
      integer   mt,nn,bnum
      character tx(*)*15
      real*8    d(*)

      save

      if(ior.lt.0) then
        bnum = 0
        call feapsync(bnum)
      end if
      tinput = tinput2(tx,mt,d,nn)

      end
\end{verbatim}
\section{Getting and setting scalars}

The {\tt feapget} routine either reads a common block variable from
the standard input or writes a common block variable to the 
standard output, depending on whether the mode is {\tt r} or {\tt w}.
If no such variable is available, the routine doesn't do anything.
The data is always sent in text format.

NOTE:  The FORTRAN {\tt read} statement is not very smart, so if
the client tries to write a double value into an integer variable,
the FORTRAN I/O library is likely to complain and abort the program.

\begin{verbatim}
      subroutine feapget(var, mode)
\end{verbatim}
\section{Sending matrices}

The {\tt feapgetm(var)} command fetches the named array from
FEAP's dynamic memory system using {\tt pgetd}.   If the array
is found, {\tt feapgetm} calls {\tt feapsendint} or {\tt feapsenddbl}
in order to return the data to the client.  Otherwise, it prints
a ``Not found'' message.

There are two variants of this routine.  The code below works with
newer versions of FEAP (8.0+) in which the {\tt p\_point.h} header
declares an integer variable capable of storing a FEAP pointer.
The code in {\tt feapgetm7.f} works with earlier versions of FEAP
in which pointers are always represented as 32-bit integers.

\begin{verbatim}
      subroutine feapgetm(var)

      implicit  none

      include 'comblk.h'
      include 'pointer.h'
      include 'p_point.h'

      character var*(*)
      logical flag
      integer lengt, prec

      save

      call pgetd( var, point, lengt, prec, flag )
      if(flag) then
        if(prec.eq.1) then
          call fmsendint(mr(point), lengt)
        else
          call fmsenddbl(hr(point), lengt)
        endif
      else
        print *, 'Not found'
      endif

      end
\end{verbatim}
\section{Receiving matrices}

The {\tt feapsetm} command is exactly analogous to {\tt feapgetm},
except that it receives data from the client using {\tt feaprecvint}
and {\tt feaprecvdbl} where {\tt feapgetm} sends data. 

\begin{verbatim}
      subroutine feapsetm(var)
\end{verbatim}
\section{FORTRAN sparse matrix output support}

The {\tt matspew} command is based on the sparse matrix output
routine available at {\tt www.ce.berkeley.edu/\~{}rlt/feap/umacr3.f}.
The {\tt matspew} routine differs from the original routine
primarily in that it calls a function {\tt writeaij} where the
original routine would write a coordinate triple to file.
The {\tt writeaij} routine takes {\tt i}, {\tt j}, and {\tt Aij},
but it also takes an additional argument that controls the precise
behavior of the routine -- if negative, it tells {\tt writeaij}
to write binary or text data.  If the argument is non-negative,
{\tt writeaij} writes no output, but increments the argument with
each call in order to compute the number of nonzeroes that would
be written.

The routine can output the following matrices:
\begin{itemize}
\item Tangent ({\tt tang}) and unsymmetric tangent( {\tt utan})
\item Consistent mass ({\tt mass} or {\tt cmas}), lumped mass
({\tt lmas}), or unsymmetric mass ({\tt umas})
\item Consistent damping ({\tt damp} or {\tt cdam})
or unsymmetric damping ({\tt udam})
\end{itemize}

\begin{verbatim}
      subroutine matspew(lct, cnt)
\end{verbatim}
\section{Clearing the solution flag}

The FEAP common block flag {\tt fl(8)} is used to keep track of
whether or not the residual has been formed since the last {\tt solv}
call.  If it has already been formed, there's no reason to form it
again.  But when we do a calculation on MATLAB and directly write
to the FEAP vectors containing the current state, whatever residual
might be in FEAP's memory is invalidated.  We therefore use 
{\tt feaptformed} to clear the value of {\tt fl(8)} so that FEAP
will know when such an event has happened.

\begin{verbatim}
      subroutine feaptformed()

      implicit  none

      include  'fdata.h'

      save

      fl(8) = .false.

      end
\end{verbatim}
\section{The FEAP dispatch macro}

The FEAP user macro {\tt serv} plays two roles.  If called with
a positive integer argument (e.g. {\tt serv,,1}), FEAP will call
{\tt feapsync} to output a string that the MATLAB client can
use for synchronization.  Otherwise, FEAP will call the {\tt feapsrv}
dispatcher routine, which allows the MATLAB client to access most of
the MATFEAP-specific functionality available.

\begin{verbatim}
      subroutine umacr1(lct,ctl,prt)

c      * * F E A P * * A Finite Element Analysis Program

c....  Copyright (c) 1984-2006: Regents of the University of California
c                               All rights reserved

c-----[--.----+----.----+----.-----------------------------------------]
c     Modification log                                Date (dd/mm/year)
c       Original version                                    01/11/2006
c-----[--.----+----.----+----.-----------------------------------------]
c      Purpose:  User interface for adding solution command language
c                instructions.

c      Inputs:
c         lct       - Command character parameters
c         ctl(3)    - Command numerical parameters
c         prt       - Flag, output if true

c      Outputs:
c         N.B.  Users are responsible for command actions.  See
c               programmers manual for example.
c-----[--.----+----.----+----.-----------------------------------------]
      implicit  none

      include  'iofile.h'
      include  'umac1.h'

      logical   pcomp,prt
      character lct*15
      real*8    ctl(3)
      integer   ival

      save

c     Set command word

      if(pcomp(uct,'mac1',4)) then      ! Usual    form
        uct = 'serv'                    ! Specify 'name'
      elseif(urest.eq.1) then           ! Read  restart data

      elseif(urest.eq.2) then           ! Write restart data

      else                              ! Perform user operation
        ival = ctl(1)
        if(ival.gt.0) then
          call feapsync(ival)
        else
          call feapsrv()
        endif
      endif

      end
\end{verbatim}
 \section{Generated files}

 We mostly augment FEAP by adding new files, but there are a few minor
 changes that we have to make to the existing files as well.  Because
 MATFEAP is supposed to work with different versions of FEAP, and because
 some of the files we need to modify vary between FEAP versions, we
 automatically rewrite the FEAP sources with scripts, rather than trying
 to come up with a one or more modified routine that will be compatible with
 all the relevant versions.

 The most obvious change is to the FEAP front-end routine.  We add calls
 to {\tt feapserver} (to start the socket server) and to {\tt feapsrv}
 (so that the user can set parameters, change directories, etc. before
 entering filenames and processing the input file.

\begin{verbatim}

feap.f: $(FEAPMAIN)
        $(AWK) ' \
        /call pstart/ { \
          print "      call feapserver()"; \
          print "      call feapsrv()" } \
        { print }' $(FEAPMAIN) > feap.f

\end{verbatim}
 FEAP calls the {\tt plstop} routine to close files, clear memory, and
 otherwise clean up before exiting.  It causes problems on some systems
 to close the socket connection before FEAP finishes writing whatever
 it will to the standard output, so we add a synchronization call at
 the very end of {\tt plstop}, just before the true exit.

\begin{verbatim}
plstop.f: $(PLSTOP)
        $(AWK) ' \
        /^[ ]*stop/ { print "      call feapsync(1)" } \
        { print }' $(PLSTOP) > plstop.f

\end{verbatim}
 The {\tt filnam} routine, which reads in file names from the standard
 input, requires four modifications:
 \begin{enumerate}
 \item  We need to make sure that
   {\tt filnam} doesn't decide to use the default file names saved in the
   {\tt feapname} file (which is what the ordinary FEAP routine does).
   So we strategically insert the statement {\tt lfil = .false.} (indicating
   that there's no {\tt feapname} to read) immediately before where FEAP
   tests {\tt lfil}.  
 \item   We add initialization routines for the
   various filename variables, fixing a bug in FEAP that would otherwise
   cause the program to go into a tailspin if we tried to quit rather than
   entering filenames.  
 \item  We make a call to {\tt cleannam} to turn any
   carriage returns and line feeds received by FEAP into ordinary spaces
   (it's unclear to me why these characters show up when I send the data
   over a socket and not over the terminal, but it seems that they do).
 \item   We add a call to {\tt feapsync} before each
   read, so that the client will know when it's supposed to provide input.
 \end{enumerate}

\begin{verbatim}
filnam.f:
        $(AWK) ' \
        /if\(lfil\) then/          { print "      lfil = .false."; init = 1 } \
        init == 1 && /^      else/ { init = 2 } \
        init == 2 && /^[ ]*p/      { print; sub(/ p/, " f") } \
        init == 2 && /^[ ]*end/    { init = 0 } \
        /^[0-9 \t]*read/           { print "      call feapsync(0)" } \
        /.not.pcomp\(filein/       { print "      call cleannam(filein)" }  \
        { print }' $(FEAPHOME)/program/filnam.f > filnam.f

\end{verbatim}
 The {\tt tinput} routine mediates most (though not all) of 
 FEAP's standard input.  Prior to version 8.0, {\tt tinput} was in the
 program subdirectory.  Since 8.0, there has been a special UNIX version
 of {\tt tinput} that uses a {\tt select} loop to keep X11 plots up to
 date while waiting for user input at the console.  We just need to
 find the version that's appropriate, copy it to the local directory,
 and rename it to {\tt tinput2}.  We have our own version of {\tt tinput}
 that will call {\tt tinput2} and then call {\tt feapsync} to allow
 the client to synchronize with the server.
\begin{verbatim}
tinput2.f: 
        if grep "function tinput" $(FEAPHOME)/program/*.f > /dev/null ; \
                then cp $(FEAPHOME)/program/tinput.f tinput0.f ; \
                else cp $(FEAPHOME)/unix/tinput.f tinput0.f ; \
                fi
        $(AWK) '{ gsub(/tinput/, "tinput2"); print }' tinput0.f > tinput2.f
        rm tinput0.f

\end{verbatim}
